pipeline {
    agent any
    parameters {
        string(name: 'dockerComposePath', value: "", description: "Path of the docker-compose.yml"),
        string(name: 'dockerfilePath', value: "", description: "Path of the Dockerfile"),
        base64File description: 'File containing the endpoints to be tested by SQLmap', name: 'endpoints'
    }
    environment {
        REPO_URL = ''
        CURR_BRANCH = ''
        workspace = ''
        relativeWorkspacePath = ''
        SNYK_TOKEN = credentials('snyk-token')
    }
    }
    stages {
        stage ('Checkout SCM') 
        {
            steps {
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    script {
                        checkout scm
                        workspace = pwd ()
                    }
                }
            }
        }
        stage('Setting Environment Variables') {
            steps {
                script {

                    echo "Getting git repo info"
                    // Get the current repository URL
                    REPO_URL = sh(script: 'git config --get remote.origin.url', returnStdout: true).trim()
                    CURR_BRANCH = sh(script: 'git rev-parse --abbrev-ref HEAD', returnStdout: true).trim()
                }  
            }
        }   
        stage('Check and build Docker Images') {
            steps {
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {  
                    script {
                        def images = []

                        if (dockerComposePath?.trim()) {
                            // If dockerComposePath is provided, run docker-compose to build images
                            echo "Docker Compose file detected. Building images using docker-compose..."
                            sh """
                                docker-compose -f ${dockerComposePath} build --parallel
                            """
                            
                            // Get repository and tag of the images created by docker-compose
                            images = sh(script: """
                                docker-compose -f ${dockerComposePath} images --format '{{.Repository}}:{{.Tag}}'
                            """, returnStdout: true).trim().split("\n")                       

                        } else if (dockerfilePath?.trim()) {
                            // If dockerComposePath is NOT provided, build the Docker image using the Dockerfile
                            echo "Dockerfile detected. Building image using docker build..."
                            
                            def imageName = "my_image:latest" // You can customize the image name as needed
                            sh """
                                docker build -t ${imageName} -f ${dockerfilePath} .
                            """
                            
                            echo "Image built from Dockerfile: ${imageName}"
                            images << imageName
                        } else {
                            error "No Dockerfile or Docker Compose file provided. Please provide at least one."
                        }

                        // Save images to an environment variable for later stages
                        env.IMAGES = images.join(",")
                    }
                }
            }    
        }
        stage('TruffleHog Secret Scan') {
            steps {
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {                
                    script {
                        echo "Running Trufflehog Scan"
                        sh 'rm -f trufflehog'

                        sh """ 
                        docker run --rm trufflesecurity/trufflehog:latest git ${REPO_URL} --since-commit HEAD --only-verified > trufflehog
                        """

                        def truffle = readFile "trufflehog" 
                        
                        if (truffle.length() == 0) {
                            echo "Good to go. No secrets found" 
                        }
                        else {
                            echo "Warning! Secrets are committed into your git repository."
                            throw new Exception("Secrets might be committed into your git repo")
                        }
                    }
                }
            }
        }
        stage('Build') {
            steps {
                echo "Building"
            }
        }
        stage('Snyk Docker Image vulnerability scan') {
            steps {
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    script {
                        // Use Snyk to scan each image
                        def images = env.IMAGES.split(",")

                        for (image in images) {
                            def sanitizedImageName = image.replaceAll("/", "_").replaceAll(":", "_")

                            echo "Scanning image: ${image} using Snyk..."

                            sh "rm -f snyk_${sanitizedImageName}"

                            sh """
                                docker run --rm -it --env ${SNYK_TOKEN} -v /var/run/docker.sock:/var/run/docker.sock \ 
                                snyk/snyk:docker snyk test --docker ${image} --severity-threshold=critical --fail-on=all > snyk_${sanitizedImageName}
                            """
                        }
                    }
                }
                script {
                    // TODO: Add the exception if a vulnerability is found in the file.
                }
            }
        }
        stage('SQL map endpoints scan') {
            steps {
                withFileParameter('endpoints') {
                    sh """
                    docker run --rm -v ${PWD}:/usr/src/myapp -w /usr/src/myapp thanosefsta/sqlmap:latest \ 
                    -u "http://testphp.vulnweb.com/artists.php?artist=1%27" --batch
                    """
                }
            }
        }
        stage('Clean up') {
            steps {
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    script {
                        
                    }
                }
            }
        }
        
    }

    post {
        always {
            echo 'Cleaning up...'
            // Perform cleanup or archive reports
        }
        success {
            echo 'Pipeline completed successfully.'
        }
        failure {
            echo 'Pipeline failed. Please check the logs.'
        }
    }
}